#pragma config(Hubs,  S1, HTServo,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     back,           sensorI2CCustom)
#pragma config(Sensor, S4,     frontSonar,     sensorSONAR)
#pragma config(Motor,  mtr_S1_C2_1,     conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     driveL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     powerLifterL,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     driveR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     powerLifterR,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  // handles Bluetooth messages
#include "../../Drivers/hitechnic-irseeker-v2.h" // handles the IR sensors

// driveFor(rotations, direction) - drives the robot for x rotations
// assumption: drive in a straight line
// true = forward, false: reverse
void driveFor(float rotations, bool direction) {
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;
	int target = rotations * 1440;
	if (direction) {
		while(nMotorEncoder[driveL] <= target || nMotorEncoder[driveR] <= target) {
			motor[driveL] = motor[driveR] = 30;
		}
		motor[driveL] = motor[driveR] = 0;
	}
	else {
		target *= -1;
		while(nMotorEncoder[driveL] >= target || nMotorEncoder[driveR] >= target) {
			motor[driveL] = motor[driveR] = -30;
		}
	}
	motor[driveL] = motor[driveR] = 0;
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0; // not sure if resetting twice helps
}

// IR code, written mostly by Coach Helms.
int _dirEnh, _strEnh; // raw values from IR sensor

// IRtask() - continuously polls the IR sensor, breaks on error
task IRtask() {
	// set the DSP to the the desired mode (1200 Hz beacon)
  HTIRS2setDSPMode(back, DSP_1200);
  while(true) {
		if (!HTIRS2readEnhanced(back, _dirEnh, _strEnh)) {
    	break; // I2C read error occurred
    }
		wait1Msec(100); // wait 100ms before polling again
  }
}

// checkBeacon() - checks if there is a beacon present at the current location
bool checkBeacon() {
	bool found = false; // assume we didn't find the beacon

	float irlocation = 0;
  int numSamples = 5;
	// take IR_SAMPLES from our IR sensor (100ms) each
	for (int i = 0; i < numSamples; i++) {
		irlocation += _dirEnh;
		wait1Msec(100);
	}
	irlocation /= numSamples;

	if (irlocation >= 4.85 && irlocation <= 5.5) {
		// we found the IR sensor, and we are lined up
	  found = true;
	}

	return found;
}

// ramp() - drives to the ramp
void ramp() {
	servo[door] = 0;
	// in theory: while the robot is more than 10 away from the wall, drive forward
	while(SensorValue[frontSonar] > 10) {
		motor[driveL] = motor[driveR] = 50;
		motor[lift] = 50;
	}
	PlayTone(2500, 100);
	motor[driveL] = motor[driveR] = 0; // STOP once we get near the wall
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;
	wait1Msec(500);

	// turn ~90 degrees right
	while(nMotorEncoder[driveL] < 1700) {
		motor[driveL] = 60;
		motor[driveR] = -30;
	}
	motor[driveL] = motor[driveR] = 0;
	wait1Msec(500);

	// run lift down
	motor[lift] = -20;
	wait1Msec(750);
	motor[lift] = 0;

	// in theory: drive forward enough to get to the ramp
	driveFor(2.25, true);
	PlayTone(1750, 100);
	wait1Msec(500);

	// in theory: turn 90 degrees right (face ramp)
	while(nMotorEncoder[driveL] < 2300) {
		motor[driveL] = 60;
		motor[driveR] = -30;
	}
	motor[driveL] = motor[driveR] = 0;
	wait1Msec(500);
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;
	// in theory: drive far enough to get completely on the ramp
	while(nMotorEncoder[driveL] <= 4464) { // 3.25 revs
		motor[driveL] = motor[driveR] = 60;
	}
	motor[driveL] = motor[driveR] = 0;
}
// main() - the main task for the robot, basically an infinite loop.
// This must be the last routine in the file.
// At the end of the autonomous period, the FMS will autonmatically halt execution.
// For this to work, the robot must be placed like this:
/*
             BLKS              (red alliance)
            +----x-------------R--------x------+
            |xxxx               \        xx FLAG
            |xxx                 \         xxRED
            |xx                   \          xx|
            x                      \           x
            |                       v          |
            |                  x               |
            |         x        xx              |
            |         xx        xx             |
            |   BLU    xx        xx   RED      |
            |   BINS    xx  RAMP  xx  BINS     |
            |            xx        xx          |
            |             xx        x          |
            |              x                   |
            |                                  |
            x            ^                     |
            |xx           \                    x
            |  xx          \                 xx|
            BLU xx          \               xxx|
            FLAG  xx         \             xxxx|
            +-------x---------R-----------x----+
                              (blu alli)   BLKS
*/
task main() {
	waitForStart(); // wait for start of autonomous

	// stage 1.5: wait for our alliance partner to get out of the way
	PlayTone(600, 600);
	wait1Msec(6000); // wait for our alliance partner to do something (6sec for ashbots)


	// initialization
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;

	StartTask(IRtask); // start polling the IR sensors

	// stage 1: run the lift up (wait empirically determined)
	motor[lift] = 75;
	wait1Msec(2200);
	motor[lift] = 0;


	// stage 2: drive to the crates and check the IR values
	// driveFor values empirically determined (check these?)
	driveFor(1.4, true);
	PlayTone(400, 100); // DEBUG
	if (checkBeacon()) { // found at 1st crate
		// TODO: DRY this
		servo[door] = 255;
		motor[lift] = 60;
		wait1Msec(1000);
		driveFor(0.05, true); // jitter the blocks a little
		wait1Msec(100);
		ramp();
	}
	else { // not at 1st crate
		driveFor(0.8, true); // drive to 2nd crate
		PlayTone(800, 150); // DEBUG
		if (checkBeacon()) { // found at 2nd crate
			servo[door] = 255;
			motor[lift] = 60;
			wait1Msec(1000);
			driveFor(0.05, true); // jitter the blocks a little
			wait1Msec(100);
			ramp();
		}
		else { // not at 2nd crate
			driveFor(1.3, true); // longer to move past the pendulum's midsection
			PlayTone(1200, 200); // DEBUG
			if (checkBeacon()) { // found at 3rd crate
				servo[door] = 255;
				motor[lift] = 60;
				wait1Msec(1000);
				driveFor(0.05, true); // jitter the blocks a little
				wait1Msec(100);
				ramp();
			}
			else { // not at 3rd crate, therefore must be at 4th (or we missed the beacon)
			  driveFor(0.80, true);
			  PlayTone(1600, 250);
			  servo[door] = 255;
			  motor[lift] = 60;
			  wait1Msec(1000);
			  driveFor(0.05, true); // jitter the blocks a little
				wait1Msec(100);
			  ramp();
			}
		}
	}
}
