#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     front,          sensorI2CCustom)
#pragma config(Sensor, S3,     back,           sensorI2CCustom)
#pragma config(Sensor, S4,     frontSonar,     sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     driveR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     driveL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     powerLifterL,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     powerLifterR,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  // handles Bluetooth messages
#include "../../Drivers/hitechnic-irseeker-v2.h" // handles the IR sensors

// driveFor(rotations, direction) - drives the robot for x rotations
// assumption: drive in a straight line
// true = forward, false: reverse
void driveFor(float rotations, bool direction) {
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;
	int target = rotations * 1440;
	if (direction) {
		while(nMotorEncoder[driveL] <= target || nMotorEncoder[driveR] <= target) {
			motor[driveL] = motor[driveR] = 30;
		}
		motor[driveL] = motor[driveR] = 0;
	}
	else {
		target *= -1;
		while(nMotorEncoder[driveL] >= target || nMotorEncoder[driveR] >= target) {
			motor[driveL] = motor[driveR] = -30;
		}
	}
	motor[driveL] = motor[driveR] = 0;
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0; // not sure if resetting twice helps
}

// main() - the main task for the robot, basically an infinite loop.
// This must be the last routine in the file.
// At the end of the autonomous period, the FMS will autonmatically halt execution.
// For this to work, the robot must be placed like this:
/*
             BLKS              (red alliance)
            +----x-------------R--------x------+
            |xxxx               \        xx FLAG
            |xxx                 \         xxRED
            |xx                   \          xx|
            x                      \           x
            |                       v          |
            |                  x               |
            |         x        xx              |
            |         xx        xx             |
            |   BLU    xx        xx   RED      |
            |   BINS    xx  RAMP  xx  BINS     |
            |            xx        xx          |
            |             xx        x          |
            |              x                   |
            |                                  |
            x            ^                     |
            |xx           \                    x
            |  xx          \                 xx|
            BLU xx          \               xxx|
            FLAG  xx         \             xxxx|
            +-------x---------R-----------x----+
                              (blu alli)   BLKS
*/
task main() {
	waitForStart(); // wait for start of autonomous

	// initialization
	nMotorEncoder[driveL] = nMotorEncoder[driveR] = 0;

	// stage 1: drive forward
	driveFor(1.5, true);

	// stage 2: turn left
	while(nMotorEncoder[driveR] < 2520) {
		motor[driveR] = 60;
		motor[driveL] = -30;
	}

	// stage 3: drive straight
	driveFor(2, true);

	// stage 4: stop
	motor[driveL] = motor[driveR] = 0;
}
