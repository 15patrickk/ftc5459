#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     driveR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     driveL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

// main() - the main task for the robot. this is basically an infinite loop.
// DO NOT MODIFY unless you've been cleared for it/know what you're doing.
// This must be the last routine in the file.
// Game controller information is sent every ~50 milliseconds from the FMS (Field Management System).
// At the end of the tele-op period, the FMS will autonmatically halt execution.
task main() {
	bool doorRaised = false; // perhaps we need to eliminate this assumption.

	// initialization: set all motors/zero to zero
	motor[driveL] = 0;
	motor[driveR] = 0;
	motor[lift] = 0;
	motor[conveyor] = 0;
	servo[door] = 255;

  waitForStart(); // wait for start of tele-op phase

  while(true) {
  	getJoystickSettings(joystick); // updates joystick info every 50-100ms

  	// motor control: if the joystick is outside the dead zone, set the corresponding motor to the value; else 0
  	// TODO: get a more sophisticated model
  	motor[driveL] = abs(joystick.joy1_y1) > 5 ? joystick.joy1_y1 : 0;
  	motor[driveR] = abs(joystick.joy1_y2) > 5 ? joystick.joy1_y2 : 0;

  	// lift control: run the lift in forward/reverse if the suitable buttons are pressed
  	/* this is a nested ternary operator. it is the equivalent of saying:
         if the down button is pressed, lower the lift. else...
           if the up button is pressed, raise the lift. else...
             set the motor to zero.
    */
  	motor[lift] = joy1Btn(7) ? -25 : joy1Btn(5) ? 50 : 0; // TODO: ask GK about appropriate motor values

  	// conveyor control: if the button is pressed, run the conveyor
  	motor[conveyor] = joy1Btn(8) ? 50 : 0; // TODO: ask EK about appropriate motor values

  	// door control: if the button is pressed, toggle the door
  	// TODO: test
  	if (joy1Btn(6)) {
  		if (doorRaised) {
  			servo[door] = 0;
  		}
  		else {
  			servo[door] = 255;
  		}
  		doorRaised = !doorRaised;
  		wait1Msec(100);
  	}

  	// brake control: if the button is pressed, toggle the motor brakes
    // FOR DICKENS' SAKES BE CAREFUL WHEN USING THIS. for safety reasons, assigned to an inconvenient button.
    bFloatDuringInactiveMotorPWM = joy1Btn(9) ? !bFloatDuringInactiveMotorPWM : bFloatDuringInactiveMotorPWM;
  }
}
